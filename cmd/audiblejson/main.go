package main

import (
	"fmt"
	"os"
	"encoding/json"
	"io/ioutil"
)

func main() {
	// Open our jsonFile
	jsonFile, err := os.Open("chapters.json")
	// if we os.Open returns an error then handle it
	if err != nil {
	    fmt.Println(err)
	}
	fmt.Println("Successfully Opened chapters.json")
	// defer the closing of our jsonFile so that we can parse it later on
	defer jsonFile.Close()

	type Chapter struct {
		Length string `json:"length_ms"`
		Offset string `json:"start_offset_sec"`
	}
	type ChapterInfo struct {
		Chapters []Chapter `json:"chapter_info"`
	}
	type Meta struct {
		Meta ChapterInfo `json:"content_metadata"`

	}

	

	

	byteValue, _ := ioutil.ReadAll(jsonFile)
	var meta Meta

	json.Unmarshal(byteValue, &meta)

	//fmt.Println(meta.ChapterInfo.Chapters.Length)
	fmt.Println(meta)


	// ------------------------

	type AutoGenerated struct {
		ContentMetadata struct {
			ChapterInfo struct {
				BrandIntroDurationMs int `json:"brandIntroDurationMs"`
				BrandOutroDurationMs int `json:"brandOutroDurationMs"`
				Chapters             []struct {
					LengthMs       int    `json:"length_ms"`
					StartOffsetMs  int    `json:"start_offset_ms"`
					StartOffsetSec int    `json:"start_offset_sec"`
					Title          string `json:"title"`
					Chapters       []struct {
						LengthMs       int    `json:"length_ms"`
						StartOffsetMs  int    `json:"start_offset_ms"`
						StartOffsetSec int    `json:"start_offset_sec"`
						Title          string `json:"title"`
					} `json:"chapters,omitempty"`
				} `json:"chapters"`
				IsAccurate       bool `json:"is_accurate"`
				RuntimeLengthMs  int  `json:"runtime_length_ms"`
				RuntimeLengthSec int  `json:"runtime_length_sec"`
			} `json:"chapter_info"`
			ContentReference struct {
				Acr                string `json:"acr"`
				Asin               string `json:"asin"`
				Codec              string `json:"codec"`
				ContentFormat      string `json:"content_format"`
				ContentSizeInBytes int    `json:"content_size_in_bytes"`
				FileVersion        string `json:"file_version"`
				Marketplace        string `json:"marketplace"`
				Sku                string `json:"sku"`
				Tempo              string `json:"tempo"`
				Version            string `json:"version"`
			} `json:"content_reference"`
			LastPositionHeard struct {
				Status string `json:"status"`
			} `json:"last_position_heard"`
		} `json:"content_metadata"`
		ResponseGroups []string `json:"response_groups"`
	}

	var auto AutoGenerated
	json.Unmarshal(byteValue, &auto)
	fmt.Println(len(auto.ContentMetadata.ChapterInfo.Chapters))
	var ch = auto.ContentMetadata.ChapterInfo.Chapters
	for i := 0; i < len(auto.ContentMetadata.ChapterInfo.Chapters); i++ {
		fmt.Println(auto.ContentMetadata.ChapterInfo.Chapters[i].Title)
	}
	for j := 0; j < len(ch); j++ {
		subch := ch[j].Chapters
		if len(ch[j].Chapters) != 0 {
			for k := 0; k < len(subch); k++ {
				fmt.Println(subch[k].Title)
				fmt.Println(subch[k].StartOffsetSec)
				fmt.Println(subch[k].LengthMs / 1000)
				fmt.Println("ffmpeg -ss", subch[k].StartOffsetSec, "-t", subch[k].LengthMs / 1000, "-i 'Blockchain Basics- A Non-Technical Introduction in 25 Steps.mp3' -acodec copy ", "'"+subch[k].Title+".mp3'")
			}
		}
	}


}
